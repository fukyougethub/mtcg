<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Team Generator (converted)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;background:#f7f7fb;color:#111;margin:0;padding:20px}
    .container{max-width:1000px;margin:0 auto;background:#fff;border-radius:12px;padding:18px;box-shadow:0 6px 30px rgba(18,24,40,0.06)}
    h1{font-size:18px;margin:0 0 12px}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
    label{display:flex;align-items:center;gap:8px;padding:6px;border-radius:6px}
    .controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
    button{padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:white;cursor:pointer}
    button.secondary{background:#6b7280}
    .output{margin-top:12px;padding:10px;background:#f3f4f6;border-radius:8px;white-space:pre-wrap}
    .modal{position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center}
    .modal .panel{background:white;padding:16px;border-radius:8px;max-width:560px;width:100%}
    .small{font-size:13px;color:#374151}
    input[type=text],input[type=number]{width:100%;padding:8px;border-radius:6px;border:1px solid #e5e7eb}
    .row{display:flex;gap:8px}
    .hint{font-size:12px;color:#6b7280}
  </style>
</head>
<body>
  <div class="container">
    <h1>Pick 6 troops for the rating: (9.9 is the max points a team could be)</h1><div id="pieces" class="grid"></div>

<div class="controls">
  <button id="rateBtn">Rate my team</button>
  <button id="genBtn">Generate a good team</button>
  <button id="customBtn" class="secondary">Custom Team Finder</button>
  <button id="bestBtn" class="secondary">Find BEST possible team</button>
  <div style="margin-left:auto" class="hint">Total pieces: <span id="totalCount"></span></div>
</div>

<div id="out" class="output">Results will appear here.</div>

  </div>  <!-- custom modal -->  <div id="modal" class="modal" style="display:none">
    <div class="panel">
      <h3>Custom Team Options</h3>
      <label class="small">Minimum Score:</label>
      <input id="minScore" type="number" step="0.1" value="7.0" /><label class="small" style="margin-top:8px">Required Troops (comma separated):</label>
  <input id="reqTroops" type="text" placeholder="e.g. PRINCE, WIZARD" />

  <label class="small" style="margin-top:8px">Required Groups (format: GROUP:count, comma separated):</label>
  <input id="reqGroups" type="text" placeholder="e.g. NOBLE:2, UNDEAD:1" />

  <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
    <button id="findCustom">Find Team</button>
    <button id="closeModal" class="secondary">Close</button>
  </div>
</div>

  </div>  <script>
    // ---- Data (converted from Python) ----
    const TYPES = ["TANK", "ASSASSIN", "DAMAGE DEALER", "CONTROLLER", "MARKSMEN", "ARTILLERY"];

    const GROUPS = {
      "NOBLE": ["KNIGHT", "PRINCE", "PRINCESS", "GOLDEN KNIGHT", "MUSKETEER"],
      "JUGGERNAUT": ["KNIGHT", "VALKYRIE", "GOBLIN MACHINE", "SKELETON KING"],
      "CLAN": ["ARCHER", "BARBARIAN", "VALKYRIE", "ARCHER QUEEN"],
      "RANGER": ["ARCHER", "DART GOBLIN", "PRINCESS", "SKELETON DRAGONS"],
      "GOBLIN": ["GOBLINS", "SPEAR GOBLINS", "DART GOBLIN", "GOBLIN MACHINE"],
      "ASSASSIN": ["GOBLINS", "ROYAL GHOST", "GOLDEN KNIGHT", "BANDIT"],
      "BLASTER": ["SPEAR GOBLINS", "BABY DRAGON", "EXECUTIONER", "MUSKETEER"],
      "BRAWLER": ["BARBARIAN", "PRINCE", "GIANT SKELETON", "MEGA KNIGHT"],
      "AVENGER": ["PEKKA", "ELECTRO GIANT", "ARCHER QUEEN", "WITCH"],
      "ACE": ["PEKKA", "EXECUTIONER", "MEGA KNIGHT", "BANDIT"],
      "UNDEAD": ["WITCH", "GIANT SKELETON", "ROYAL GHOST", "SKELETON KING", "SKELETON DRAGONS"],
      "MAGE": ["WIZARD", "ELECRO WIZARD"],
      "FIRE": ["WIZARD", "BABY DRAGON"],
      "ELECTRIC": ["ELECTRO GIANT", "ELECTRO WIZARD"],
    };

    const GROUP_RANKINGS = {
      "NOBLE": 4,
      "JUGGERNAUT": 4,
      "CLAN": 4,
      "RANGER": 4,
      "GOBLIN": 2,
      "ASSASSIN": 3,
      "BLASTER": 2,
      "BRAWLER": 1,
      "AVENGER": 3,
      "ACE": 2,
      "UNDEAD": 5,
      "MAGE": 4,
      "FIRE": 3,
      "ELECTRIC": 2,
    };

    const PIECES = {
      "KNIGHT":   {"type": "TANK", "group1": "NOBLE", "group2": "JUGGERNAUT"},
      "PRINCE":   {"type": "ASSASSIN", "group1": "NOBLE", "group2": "BRAWLER"},
      "PRINCESS": {"type": "ARTILLERY", "group1": "NOBLE", "group2": "RANGER"},
      "GOLDEN KNIGHT": {"type": "ASSASSIN", "group1": "NOBLE", "group2": "ASSASSIN"},
      "PEKKA": {"type": "DAMAGE DEALER", "group1": "AVENGER", "group2": "ACE"},
      "GOBLIN MACHINE": {"type": "CONTROLLER", "group1": "JUGGERNAUT", "group2": "GOBLIN"},
      "SKELETON KING": {"type": "DAMAGE DEALER", "group1": "JUGGERNAUT", "group2": "UNDEAD"},
      "ARCHER": {"type": "MARKSMEN", "group1": "CLAN", "group2": "RANGER"},
      "BARBARIAN": {"type": "CONTROLLER", "group1": "CLAN", "group2": "BRAWLER"},
      "VALKYRIE": {"type": "TANK", "group1": "CLAN", "group2": "JUGGERNAUT"},
      "ARCHER QUEEN": {"type": "MARKSMEN", "group1": "CLAN", "group2": "AVENGER"},
      "DART GOBLIN": {"type": "MARKSMEN", "group1": "GOBLIN", "group2": "RANGER"},
      "GOBLINS": {"type": "ASSASSIN", "group1": "GOBLIN", "group2": "ASSASSIN"},
      "SPEAR GOBLINS": {"type": "DAMAGE DEALER", "group1": "GOBLIN", "group2": "BLASTER"},
      "ROYAL GHOST": {"type": "ASSASSIN", "group1": "ASSASSIN", "group2": "UNDEAD"},
      "WIZARD": {"type": "ARTILLERY", "group1": "FIRE", "group2": "MAGE"},
      "EXECUTIONER": {"type": "ARTILLERY", "group1": "BLASTER", "group2": "ACE"},
      "GIANT SKELETON": {"type": "DAMAGE DEALER", "group1": "BRAWLER", "group2": "UNDEAD"},
      "MEGA KNIGHT": {"type": "TANK", "group1": "BRAWLER", "group2": "ACE"},
      "BANDIT": {"type": "ASSASSIN", "group1": "ASSASSIN", "group2": "ACE"},
      "SKELETON DRAGONS": {"type": "CONTROLLER", "group1": "UNDEAD", "group2": "RANGER"},
      "ELECTRO GIANT": {"type": "TANK", "group1": "ELECTRIC", "group2": "AVENGER"},
      "MUSKETEER": {"type": "MARKSMEN", "group1": "NOBLE", "group2": "BLASTER"},
      "BABY DRAGON": {"type": "ARTILLERY", "group1": "FIRE", "group2": "BLASTER"},
      "ELECTRO WIZARD": {"type": "CONTROLLER", "group1": "MAGE", "group2": "ELECTRIC"},
      "WITCH": {"type": "CONTROLLER", "group1": "UNDEAD", "group2": "AVENGER"},
    };

    // ---- Utility functions ----
    function getGroupMultiplier(g){
      const rank = GROUP_RANKINGS[g] ?? 2;
      if(rank===1) return 0.8;
      if(rank===2) return 0.9;
      if(rank===3) return 1.0;
      if(rank===4) return 1.125;
      if(rank===5) return 1.25;
      return 1.0;
    }

    function scoreGroup(chosenIds){
      const chosenSet = new Set(chosenIds);
      let score = 0;

      for(const [gname,members] of Object.entries(GROUPS)){
        const active = members.filter(m=>chosenSet.has(m)).length;
        const multiplier = getGroupMultiplier(gname);
        if(members.length===3){
          if(active===3) score += 2 * multiplier;
        } else if(members.length===4){
          if(active>=2) score += 1 * multiplier;
          if(active===4) score += 2 * multiplier;
        } else if(members.length===2){
          if(active>=2) score += 1.5 * multiplier;
        } else if(members.length===5){
          if(active>=2) score += 1 * multiplier;
          if(active===4) score += 2 * multiplier;
          if(active===5) score += 2.5 * multiplier;
        }
      }

      const chosenTypes = new Set(chosenIds.map(p => PIECES[p].type));
      if(chosenTypes.size > 1) score += chosenTypes.size / 2;
      return score;
    }

    // combinations helper (generator)
    function* combinations(arr,k){
      const n=arr.length;
      const indices = Array.from({length:k},(_,i)=>i);
      if(k>n) return;
      while(true){
        yield indices.map(i=>arr[i]);
        let i=k-1;
        while(i>=0 && indices[i]===i+n-k) i--;
        if(i<0) return;
        indices[i]++;
        for(let j=i+1;j<k;j++) indices[j]=indices[j-1]+1;
      }
    }

    function randomChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    // ---- UI wiring ----
    const piecesDiv = document.getElementById('pieces');
    const out = document.getElementById('out');
    const totalCountEl = document.getElementById('totalCount');

    const allIds = Object.keys(PIECES);
    totalCountEl.textContent = allIds.length;

    const selection = {};
    allIds.forEach(pid=>{
      const div = document.createElement('label');
      const cb = document.createElement('input'); cb.type='checkbox';
      cb.addEventListener('change',()=> selection[pid]=cb.checked ? 1 : 0);
      selection[pid]=0;
      const txt = document.createElement('span'); txt.textContent = pid;
      div.appendChild(cb); div.appendChild(txt);
      piecesDiv.appendChild(div);
    });

    function showResult(title,text){
      out.textContent = title + "\n\n" + text;
    }

    // Rate my team
    document.getElementById('rateBtn').addEventListener('click',()=>{
      const chosen = Object.entries(selection).filter(([k,v])=>v===1).map(([k])=>k);
      if(chosen.length!==6){ alert('You must pick exactly 6 troops.'); return; }
      const score = scoreGroup(chosen);
      const details = chosen.map(pid=>`${pid}: type=${PIECES[pid].type} Groups=(${PIECES[pid].group1}, ${PIECES[pid].group2})`).join('\n');
      showResult(`Team score: ${score}`, details);
    });

    // Generate a good team (search combos randomly within a score window)
    function findRandomStrongGroup(minScore=8.0, maxScore=9.0, attempts=20000){
      const combos = [];
      const keys = allIds;
      for(let i=0;i<attempts;i++){
        // pick 6 random unique
        const pick = [];
        const pool = keys.slice();
        for(let j=0;j<6;j++){
          const idx = Math.floor(Math.random()*pool.length);
          pick.push(pool.splice(idx,1)[0]);
        }
        const sc = scoreGroup(pick);
        if(sc>=minScore && sc<=maxScore) combos.push({score:sc,pick});
      }
      if(combos.length===0) return [null,null];
      return randomChoice(combos);
    }

    document.getElementById('genBtn').addEventListener('click',()=>{
      const res = findRandomStrongGroup(8.0,9.0,40000);
      if(!res || !res.pick){ alert('No team found (try again).'); return; }
      const details = res.pick.map(pid=>`${pid}: type=${PIECES[pid].type} Groups=(${PIECES[pid].group1}, ${PIECES[pid].group2})`).join('\n');
      showResult(`Team score: ${res.score}`, details);
    });

    // Custom Team Finder modal
    const modal = document.getElementById('modal');
    document.getElementById('customBtn').addEventListener('click',()=> modal.style.display='flex');
    document.getElementById('closeModal').addEventListener('click',()=> modal.style.display='none');

    document.getElementById('findCustom').addEventListener('click',()=>{
      const minScore = parseFloat(document.getElementById('minScore').value) || 8.5;
      const required_troops_raw = document.getElementById('reqTroops').value;
      const required_troops = required_troops_raw.split(',').map(s=>s.trim()).filter(Boolean);
      const groups_raw = document.getElementById('reqGroups').value;
      const group_constraints = {};
      groups_raw.split(',').map(p=>p.trim()).forEach(part=>{
        if(!part) return;
        const [g,c] = part.split(':').map(s=>s.trim());
        if(g && c) group_constraints[g.toUpperCase()] = parseInt(c,10);
      });

      // search combos randomly with constraints
      const attempts = 80000; // should find something without full enumeration in most cases
      const keys = allIds;
      for(let i=0;i<attempts;i++){
        // make random pick, but include required troops if present
        let pick = [];
        const pool = keys.slice();
        // force include required troops
        for(const rt of required_troops){
          if(!keys.includes(rt)){ pick=null; break; }
          pick.push(rt);
          const idx = pool.indexOf(rt); if(idx>=0) pool.splice(idx,1);
        }
        if(pick===null) continue;
        while(pick.length<6){ const idx=Math.floor(Math.random()*pool.length); pick.push(pool.splice(idx,1)[0]); }

        // check groups
        let ok=true;
        for(const [g,cnt] of Object.entries(group_constraints)){
          const members = GROUPS[g];
          if(!members){ ok=false; break; }
          const have = members.filter(m=>pick.includes(m)).length;
          if(have < cnt){ ok=false; break; }
        }
        if(!ok) continue;
        const sc = scoreGroup(pick);
        if(sc >= minScore){
          const details = pick.map(pid=>`${pid}: type=${PIECES[pid].type} Groups=(${PIECES[pid].group1}, ${PIECES[pid].group2})`).join('\n');
          showResult(`Team score: ${sc}`, details);
          modal.style.display='none';
          return;
        }
      }
      alert('No valid team found (try changing constraints or increase attempts).');
    });

    // Find BEST possible team (heuristic + option for exhaustive)
    async function findBestTeam(exhaustive=false){
      const keys = allIds;
      const n = keys.length;
      const totalComb = combinationCount(n,6);
      let bestScore = -Infinity, bestPick=null;
      if(exhaustive && totalComb <= 500000){
        // do full enumeration (may be slow but acceptable up to ~500k combos)
        for(const combo of combinations(keys,6)){
          const sc = scoreGroup(combo);
          if(sc > bestScore){ bestScore=sc; bestPick=combo.slice(); }
        }
        return [bestScore,bestPick];
      }
      // otherwise do Monte Carlo with many attempts
      const attempts = 300000;
      for(let i=0;i<attempts;i++){
        const pick = [];
        const pool = keys.slice();
        for(let j=0;j<6;j++){ const idx=Math.floor(Math.random()*pool.length); pick.push(pool.splice(idx,1)[0]); }
        const sc = scoreGroup(pick);
        if(sc > bestScore){ bestScore=sc; bestPick=pick.slice(); }
      }
      return [bestScore,bestPick];
    }

    function combinationCount(n,k){
      // compute nCk
      if(k>n) return 0;
      let res = 1;
      for(let i=1;i<=k;i++) res = res * (n - k + i) / i;
      return Math.round(res);
    }

    document.getElementById('bestBtn').addEventListener('click', async ()=>{
      out.textContent = 'Searching for best team... (this may take a few seconds)';
      // prefer exhaustive if small
      const total = combinationCount(allIds.length,6);
      const useExhaustive = total <= 500000; // change threshold as needed
      const [bestScore,bestPick] = await findBestTeam(useExhaustive);
      if(!bestPick){ alert('No team found'); return; }
      const details = bestPick.map(pid=>`${pid}: type=${PIECES[pid].type} Groups=(${PIECES[pid].group1}, ${PIECES[pid].group2})`).join('\n');
      showResult(`Highest Team score: ${bestScore}`, details);
    });

    // expose PIECES to templates
    // (already used above)
  </script></body>
  </html>
