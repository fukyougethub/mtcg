<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Comp Generator â€” Full</title>
  <link rel="icon" href="data:,">
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;background:#f7f7fb;color:#111;margin:0;padding:20px}
    .container{max-width:1000px;margin:0 auto;background:#fff;border-radius:12px;padding:18px;box-shadow:0 6px 30px rgba(18,24,40,0.06)}
    h1{font-size:18px;margin:0 0 12px}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
    label{display:flex;align-items:center;gap:8px;padding:6px;border-radius:6px}
    .controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
    button{padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:white;cursor:pointer}
    button.secondary{background:#6b7280}
    .output{margin-top:12px;padding:10px;background:#f3f4f6;border-radius:8px;white-space:pre-wrap;font-family:monospace}
    .modal{position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center}
    .modal .panel{background:white;padding:16px;border-radius:8px;max-width:560px;width:100%}
    .small{font-size:13px;color:#374151}
    input[type=text],input[type=number],select{width:100%;padding:8px;border-radius:6px;border:1px solid #e5e7eb}
    .hint{font-size:12px;color:#6b7280}
  </style>
</head>
<body>
  <div class="container">
    <h1>Pick troops for the rating (Trait Dummy adds 1 slot)</h1>

    <div id="pieces" class="grid"></div>

    <div style="margin-top:10px;">
      <label for="ruler">Select Ruler:</label>
      <select id="ruler">
        <option>Royale King</option>
        <option>Spirit Empress</option>
        <option>Goblin Queen</option>
        <option>Elixir Loong</option>
      </select>
    </div>

    <div style="margin-top:10px;">
      <label for="modifier">Select Modifier:</label>
      <select id="modifier">
        <option value="Default">Default</option>
        <option value="Champion Star">Champion Star</option>
        <option value="Endurance Training">Endurance Training</option>
        <option value="Fighting Fever">Fighting Fever</option>
        <option value="You're Mine">You're Mine / Echo Bench / Ascension</option>
        <option value="Last Stand">Last Stand</option>
        <option value="Trait Dummy">Trait Dummy (forced extra slot + dummy)</option>
      </select>
    </div>

    <!-- Trait Dummy UI (only visible if modifier selected) -->
    <div id="traitDummySettings" style="display:none; margin-top:10px;">
      <label for="dummyGroup1">Trait Dummy - Group 1:</label>
      <select id="dummyGroup1"></select>

      <label for="dummyGroup2" style="margin-top:6px;">Trait Dummy - Group 2:</label>
      <select id="dummyGroup2"></select>

      <div class="hint">When Trait Dummy is active we auto-add a TANK dummy with these two trait values and increase team capacity by +1 (dummy occupies that extra slot).</div>
    </div>

    <div class="controls">
      <button id="rateBtn">Rate my team</button>
      <button id="genBtn">Generate a good team</button>
      <button id="customBtn" class="secondary">Custom Team Finder</button>
      <button id="bestBtn" class="secondary">Find BEST possible team</button>
      <div style="margin-left:auto" class="hint">Pickable pieces: <span id="pickLimit">6</span> (shows +1 if Trait Dummy)</div>
    </div>

    <div id="out" class="output">Results will appear here.</div>
  </div>

  <!-- custom modal -->
  <div id="modal" class="modal" style="display:none">
    <div class="panel">
      <h3>Custom Team Options</h3>
      <label class="small">Minimum Score:</label>
      <input id="minScore" type="number" step="0.1" value="10.0" />
      <label class="small" style="margin-top:8px">Required Troops (comma separated):</label>
      <input id="reqTroops" type="text" placeholder="e.g. PRINCE, WIZARD" />
      <label class="small" style="margin-top:8px">Required Groups (format: GROUP:count, comma separated):</label>
      <input id="reqGroups" type="text" placeholder="e.g. NOBLE:2, UNDEAD:1" />
      <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
        <button id="findCustom">Find Team</button>
        <button id="closeModal" class="secondary">Close</button>
      </div>
    </div>
  </div>

  <script>
  /*************************************************************************
   * Full implementation:
   * - Trait Dummy forced when modifier is selected
   * - Dummy auto-occupies the extra slot (pickLimit increases by 1)
   * - Dummy participates in group-stage incremental scoring
   * - If a group's highest stage is reached (stage3) with dummy's help,
   *   that group's points equal stage1+stage2+stage3 = 3 cumulative points
   * - Safe wrapper resets UI on errors
   *************************************************************************/

  // safe-run & reset helpers
  function resetUI() {
    // uncheck all checkboxes
    document.querySelectorAll('#pieces input[type=checkbox]').forEach(cb => cb.checked = false);
    // remove dummy if present
    if (PIECES["_DUMMY_"]) delete PIECES["_DUMMY_"];
    // reset modifier & UI
    modifierSelect.value = 'Default';
    traitDummySettings.style.display = 'none';
    pickLimitEl.textContent = basePickLimit;
    modal.style.display = 'none';
    out.textContent = 'Results will appear here.';
  }
  function safeRun(fn) {
    try { return fn(); }
    catch (err) {
      console.error(err);
      resetUI();
      out.textContent = "An error occurred; UI reset. See console for details.";
    }
  }

  // DOM refs
  const piecesDiv = document.getElementById('pieces');
  const modifierSelect = document.getElementById('modifier');
  const traitDummySettings = document.getElementById('traitDummySettings');
  const dummyGroup1 = document.getElementById('dummyGroup1');
  const dummyGroup2 = document.getElementById('dummyGroup2');
  const pickLimitEl = document.getElementById('pickLimit');
  const out = document.getElementById('out');
  const modal = document.getElementById('modal');

  // Base data (original pieces/groups/rankings)
  const GROUPS = {
    "NOBLE": ["KNIGHT", "PRINCE", "PRINCESS", "GOLDEN KNIGHT", "MUSKETEER"],
    "JUGGERNAUT": ["KNIGHT", "VALKYRIE", "GOBLIN MACHINE", "SKELETON KING"],
    "CLAN": ["ARCHER", "BARBARIAN", "VALKYRIE", "ARCHER QUEEN"],
    "RANGER": ["ARCHER", "DART GOBLIN", "PRINCESS", "SKELETON DRAGONS"],
    "GOBLIN": ["GOBLINS", "SPEAR GOBLINS", "DART GOBLIN", "GOBLIN MACHINE"],
    "ASSASSIN": ["GOBLINS", "ROYAL GHOST", "GOLDEN KNIGHT", "BANDIT"],
    "BLASTER": ["SPEAR GOBLINS", "BABY DRAGON", "EXECUTIONER", "MUSKETEER"],
    "BRAWLER": ["BARBARIAN", "PRINCE", "GIANT SKELETON", "MEGA KNIGHT"],
    "AVENGER": ["PEKKA", "ELECTRO GIANT", "ARCHER QUEEN", "WITCH"],
    "ACE": ["PEKKA", "EXECUTIONER", "MEGA KNIGHT", "BANDIT"],
    "UNDEAD": ["WITCH", "GIANT SKELETON", "ROYAL GHOST", "SKELETON KING", "SKELETON DRAGONS"],
    "MAGE": ["WIZARD", "ELECTRO WIZARD"],
    "FIRE": ["WIZARD", "BABY DRAGON"],
    "ELECTRIC": ["ELECTRO GIANT", "ELECTRO WIZARD"]
  };

  const GROUP_RANKINGS = {
    "NOBLE": 5, "JUGGERNAUT": 5, "CLAN": 3, "RANGER": 2, "GOBLIN": 5, "ASSASSIN": 1,
    "BLASTER": 4, "BRAWLER": 1, "AVENGER": 3, "ACE": 5, "UNDEAD": 5, "MAGE": 2,
    "FIRE": 3, "ELECTRIC": 2
  };

  function getBonusMultiplier(b){
    if(b===1) return 0.95;
    if(b===2) return 0.98;
    if(b===3) return 1.0;
    if(b===4) return 1.03;
    if(b===5) return 1.05;
    return 1.0;
  }

  const PIECES = {
    "KNIGHT": {"type":"TANK","group1":"NOBLE","group2":"JUGGERNAUT","bonus":1,"cost":2,"abilityamount":0},
    "PRINCE": {"type":"TANK","group1":"NOBLE","group2":"BRAWLER","bonus":3,"cost":3,"abilityamount":1},
    "PRINCESS": {"type":"ARTILLERY","group1":"NOBLE","group2":"RANGER","bonus":4,"cost":4,"abilityamount":0},
    "GOLDEN KNIGHT": {"type":"ASSASSIN","group1":"NOBLE","group2":"ASSASSIN","bonus":5,"cost":5,"abilityamount":1},
    "PEKKA": {"type":"DAMAGE DEALER","group1":"AVENGER","group2":"ACE","bonus":3,"cost":3,"abilityamount":0},
    "GOBLIN MACHINE": {"type":"CONTROLLER","group1":"JUGGERNAUT","group2":"GOBLIN","bonus":4,"cost":4,"abilityamount":2},
    "SKELETON KING": {"type":"DAMAGE DEALER","group1":"JUGGERNAUT","group2":"UNDEAD","bonus":4,"cost":5,"abilityamount":1},
    "ARCHER": {"type":"MARKSMEN","group1":"CLAN","group2":"RANGER","bonus":3,"cost":2,"abilityamount":0},
    "BARBARIAN": {"type":"CONTROLLER","group1":"CLAN","group2":"BRAWLER","bonus":2,"cost":2,"abilityamount":0},
    "VALKYRIE": {"type":"TANK","group1":"CLAN","group2":"JUGGERNAUT","bonus":3,"cost":3,"abilityamount":0},
    "ARCHER QUEEN": {"type":"MARKSMEN","group1":"CLAN","group2":"AVENGER","bonus":5,"cost":5,"abilityamount":2},
    "DART GOBLIN": {"type":"MARKSMEN","group1":"GOBLIN","group2":"RANGER","bonus":2,"cost":3,"abilityamount":0},
    "GOBLINS": {"type":"ASSASSIN","group1":"GOBLIN","group2":"ASSASSIN","bonus":2,"cost":2,"abilityamount":0},
    "SPEAR GOBLINS": {"type":"DAMAGE DEALER","group1":"GOBLIN","group2":"BLASTER","bonus":1,"cost":2,"abilityamount":0},
    "ROYAL GHOST": {"type":"ASSASSIN","group1":"ASSASSIN","group2":"UNDEAD","bonus":5,"cost":4,"abilityamount":1},
    "WIZARD": {"type":"ARTILLERY","group1":"FIRE","group2":"MAGE","bonus":3,"cost":2,"abilityamount":0},
    "EXECUTIONER": {"type":"ARTILLERY","group1":"BLASTER","group2":"ACE","bonus":3,"cost":3,"abilityamount":0},
    "GIANT SKELETON": {"type":"DAMAGE DEALER","group1":"BRAWLER","group2":"UNDEAD","bonus":4,"cost":3,"abilityamount":2},
    "MEGA KNIGHT": {"type":"TANK","group1":"BRAWLER","group2":"ACE","bonus":4,"cost":4,"abilityamount":2},
    "BANDIT": {"type":"ASSASSIN","group1":"ASSASSIN","group2":"ACE","bonus":4,"cost":4,"abilityamount":1},
    "SKELETON DRAGONS": {"type":"CONTROLLER","group1":"UNDEAD","group2":"RANGER","bonus":2,"cost":2,"abilityamount":1},
    "ELECTRO GIANT": {"type":"TANK","group1":"ELECTRIC","group2":"AVENGER","bonus":3,"cost":3,"abilityamount":2},
    "MUSKETEER": {"type":"MARKSMEN","group1":"NOBLE","group2":"BLASTER","bonus":3,"cost":3,"abilityamount":1},
    "BABY DRAGON": {"type":"DAMAGE DEALER","group1":"FIRE","group2":"BLASTER","bonus":4,"cost":4,"abilityamount":0},
    "ELECTRO WIZARD": {"type":"CONTROLLER","group1":"MAGE","group2":"ELECTRIC","bonus":5,"cost":4,"abilityamount":2},
    "WITCH": {"type":"CONTROLLER","group1":"UNDEAD","group2":"AVENGER","bonus":3,"cost":4,"abilityamount":2}
  };

  // UI: build piece checkboxes (dummy is NOT included here)
  const selection = {};
  const allIds = Object.keys(PIECES);
  allIds.forEach(pid => {
    const lbl = document.createElement('label');
    const cb = document.createElement('input'); cb.type='checkbox';
    cb.addEventListener('change', ()=> selection[pid] = cb.checked ? 1 : 0);
    selection[pid] = 0;
    const span = document.createElement('span'); span.textContent = pid;
    lbl.appendChild(cb);
    lbl.appendChild(span);
    piecesDiv.appendChild(lbl);
  });

  // populate dummy trait dropdowns
  const groupNames = Object.keys(GROUPS);
  groupNames.forEach(g=>{
    const o1 = document.createElement('option'); o1.value=g; o1.textContent=g;
    const o2 = o1.cloneNode(true);
    dummyGroup1.appendChild(o1);
    dummyGroup2.appendChild(o2);
  });

  // pick limit logic
  const basePickLimit = 6; // default
  pickLimitEl.textContent = basePickLimit;

  modifierSelect.addEventListener('change', ()=>{
    const isDummy = modifierSelect.value === 'Trait Dummy';
    traitDummySettings.style.display = isDummy ? 'block' : 'none';
    pickLimitEl.textContent = isDummy ? (basePickLimit + 1) : basePickLimit;
  });

  // stage-based scoring helpers
  function stagePointsForGroup(memberCount, groupSize) {
    // We'll define 3 stages and make them incremental.
    // For groups of size 5: stages at 2,3,4
    // For size 4: stages at 2,3,4
    // For size 3: stages at 1,2,3
    // For size 2: stages at 1,2
    // Each stage contributes +1; reaching stage3 yields cumulative +3
    if (groupSize === 5) {
      let pts = 0;
      if (memberCount >= 2) pts += 1; // stage1
      if (memberCount >= 3) pts += 1; // stage2
      if (memberCount >= 4) pts += 1; // stage3 (cumulative)
      return pts;
    } else if (groupSize === 4) {
      let pts = 0;
      if (memberCount >= 2) pts += 1;
      if (memberCount >= 3) pts += 1;
      if (memberCount >= 4) pts += 1;
      return pts;
    } else if (groupSize === 3) {
      let pts = 0;
      if (memberCount >= 1) pts += 1;
      if (memberCount >= 2) pts += 1;
      if (memberCount >= 3) pts += 1;
      return pts;
    } else if (groupSize === 2) {
      let pts = 0;
      if (memberCount >= 1) pts += 1;
      if (memberCount >= 2) pts += 1;
      return pts;
    } else {
      // fallback
      return memberCount >= 2 ? 1 : 0;
    }
  }

  // main score function (includes dummy when modifier selected)
  function scoreGroup(chosenIds) {
    // copy chosenIds so we don't mutate the caller
    const chosen = chosenIds.slice();
    const chosenSet = new Set(chosen);

    // Add dummy if modifier selected â€” dummy always auto-included
    const modifierValue = modifierSelect.value || 'Default';
    let dummyAdded = false;
    if (modifierValue === 'Trait Dummy') {
      const g1 = dummyGroup1.value || Object.keys(GROUPS)[0];
      const g2 = dummyGroup2.value || Object.keys(GROUPS)[0];
      const dummy = {
        type: 'TANK',
        group1: g1,
        group2: g2,
        bonus: 2,           // influences bonus multiplier (kept moderate)
        cost: 1,            // contributes to total cost
        abilityamount: 0,
        bonusPoints: 0.5    // extra flat point contribution (you can tune)
      };
      // attach temporarily
      PIECES['_DUMMY_'] = dummy;
      chosen.push('_DUMMY_');
      chosenSet.add('_DUMMY_');
      dummyAdded = true;
    }

    // Count group activations
    const groupCounts = {};
    for (const g of Object.keys(GROUPS)) groupCounts[g] = 0;
    for (const pid of chosen) {
      const piece = PIECES[pid];
      if (!piece) continue;
      if (piece.group1) groupCounts[piece.group1] = (groupCounts[piece.group1]||0) + 1;
      if (piece.group2) groupCounts[piece.group2] = (groupCounts[piece.group2]||0) + 1;
    }

    // incremental stage scoring
    let score = 0;
    for (const [gname, members] of Object.entries(GROUPS)) {
      const count = groupCounts[gname] || 0;
      const groupSize = members.length;
      const pts = stagePointsForGroup(count, groupSize);
      // scale by ranking multiplier
      const multiplier = getGroupMultiplier(gname);
      score += pts * multiplier;
    }

    // diversity by types (same as original: +types/2)
    const chosenTypes = new Set(chosen.map(p => PIECES[p] && PIECES[p].type).filter(Boolean));
    if (chosenTypes.size > 1) score += chosenTypes.size / 2;

    // bonus multiplier from piece bonuses (product of each piece's bonus multiplier)
    let bonusMultiplier = 1;
    for (const pid of chosen) {
      const piece = PIECES[pid];
      if (piece && typeof piece.bonus !== 'undefined') {
        bonusMultiplier *= getBonusMultiplier(piece.bonus);
      }
    }

    // add flat bonusPoints from pieces (dummy uses bonusPoints to add direct points)
    let flatBonusPoints = 0;
    for (const pid of chosen) {
      const piece = PIECES[pid];
      if (piece && piece.bonusPoints) flatBonusPoints += piece.bonusPoints;
    }

    // total cost
    const totalCost = chosen.reduce((s,p) => s + ((PIECES[p] && PIECES[p].cost) || 0), 0);

    // apply ruler effects
    let final = score * bonusMultiplier + flatBonusPoints;

    const ruler = document.getElementById('ruler').value;
    if (ruler === "Royale King") final *= 1.1;
    else if (ruler === "Spirit Empress") { if (totalCost > 20) final *= 1.2; }
    else if (ruler === "Goblin Queen") {
      const hasGoblin = chosenSet.has("GOBLINS");
      const hasSpear = chosenSet.has("SPEAR GOBLINS");
      const hasDart = chosenSet.has("DART GOBLIN");
      const hasMachine = chosenSet.has("GOBLIN MACHINE");
      if (hasGoblin && hasSpear && hasDart && hasMachine) final *= 1.5;
      else if ((hasGoblin && hasSpear) || (hasDart && hasSpear) || (hasDart && hasGoblin) || (hasDart && hasSpear && hasGoblin)) final *= 1.25;
    } else if (ruler === "Elixir Loong") final *= 1.05;

    // modifier-specific multipliers (Champion Star, Endurance Training, etc.)
    // We'll implement the original modifiers briefly (Champion Star example)
    if (modifierValue === 'Champion Star') {
      const hasFive = chosen.some(pid => (PIECES[pid] && PIECES[pid].cost) === 5);
      if (hasFive) final *= 1.05;
    } else if (modifierValue === 'Endurance Training') {
      const tankCount = chosen.filter(pid => PIECES[pid] && PIECES[pid].type === 'TANK').length;
      if (tankCount > 0) final *= Math.pow(1.01, tankCount);
      // additional small synergy checks (kept lightweight)
      const activeGroups = {};
      for (const [g,members] of Object.entries(GROUPS)) activeGroups[g] = members.filter(m => chosenSet.has(m)).length;
      const checkSy = g => { const c = activeGroups[g]||0; if(c>=4) return 1.05; if(c>=2) return 1.025; return 1; };
      final *= checkSy('BRAWLER') * checkSy('JUGGERNAUT') * checkSy('CLAN') * checkSy('NOBLE');
    } else if (modifierValue === 'Fighting Fever') {
      const assassinCount = chosen.filter(pid => PIECES[pid] && PIECES[pid].type === 'ASSASSIN').length;
      if (assassinCount > 0) final *= Math.pow(1.01, assassinCount);
      // some synergy multipliers
      const activeGroups = {};
      for (const [g,members] of Object.entries(GROUPS)) activeGroups[g] = members.filter(m => chosenSet.has(m)).length;
      const checkSy = (g,aceMode=false) => { const c = activeGroups[g]||0; if(aceMode) return c>=2?1.025:1; if(c>=4) return 1.05; if(c>=2) return 1.025; return 1; };
      final *= checkSy('RANGER') * checkSy('CLAN') * checkSy('ACE', true);
    } else if (modifierValue === "You're Mine") {
      const costMult = {2:1.0,3:1.005,4:1.01,5:1.025};
      for (const pid of chosen) {
        const p = PIECES[pid];
        if (!p) continue;
        if (p.cost>=2 && p.cost<=5) final *= costMult[p.cost];
        if (p.abilityamount === 1) final *= 1.01;
        else if (p.abilityamount === 2) final *= 1.025;
      }
    } else if (modifierValue === "Last Stand") {
      const ddCount = chosen.filter(pid => PIECES[pid] && PIECES[pid].type === "DAMAGE DEALER").length;
      if (ddCount > 0) final *= Math.pow(1.01, ddCount);
      const activeGroups = {};
      for (const [g,members] of Object.entries(GROUPS)) activeGroups[g] = members.filter(m => chosenSet.has(m)).length;
      const checkSy = (g,fireMode=false) => { const c = activeGroups[g]||0; if(fireMode) return c>=2?1.025:1; if(c>=4) return 1.05; if(c>=2) return 1.025; return 1; };
      final *= checkSy('ACE') * checkSy('NOBLE') * checkSy('ASSASSIN') * checkSy('AVENGER') * checkSy('BLASTER') * checkSy('FIRE', true);
    }

    // cleanup dummy if we added it (we remove the temporary PIECES entry)
    if (dummyAdded && PIECES['_DUMMY_']) delete PIECES['_DUMMY_'];

    return { final, detail: { groupCounts, totalCost } };
  }

  // combinations generator (used by best/custom)
  function* combinations(arr, k) {
    const n = arr.length;
    if (k > n) return;
    const indices = Array.from({length:k}, (_, i) => i);
    while (true) {
      yield indices.map(i => arr[i]);
      let i = k - 1;
      while (i >= 0 && indices[i] === i + n - k) i--;
      if (i < 0) return;
      indices[i]++;
      for (let j = i + 1; j < k; j++) indices[j] = indices[j - 1] + 1;
    }
  }

  function randomChoice(arr) { return arr[Math.floor(Math.random()*arr.length)]; }

  // UI helpers
  function showResult(title, text) {
    out.textContent = title + "\n\n" + text;
  }

  // RATE button handler
  document.getElementById('rateBtn').addEventListener('click', ()=> safeRun(()=> {
    const chosen = Object.entries(selection).filter(([k,v])=>v===1).map(([k])=>k);
    // determine required picks: base = 6 (or 7 if Elixir Loong), but if Trait Dummy active we auto-add the dummy and thus require one less real pick
    const baseRequired = (document.getElementById('ruler').value === 'Elixir Loong') ? 7 : 6;
    const isDummy = modifierSelect.value === 'Trait Dummy';
    const requiredRealPicks = isDummy ? baseRequired - 1 : baseRequired;

    if (chosen.length !== requiredRealPicks) {
      alert(`You must pick exactly ${requiredRealPicks} real troops${isDummy ? " (plus the forced dummy)":"."}`);
      return;
    }

    const res = scoreGroup(chosen);
    // compute total cost (including dummy if active)
    // scoreGroup returned groupCounts & totalCost inside detail - but we used dynamic PIECES so compute again safely
    // We'll call scoreGroup again to get final and detail (already returned)
    const finalScore = res.final;
    // show details: chosen pieces + dummy if any
    const isDummyActive = modifierSelect.value === 'Trait Dummy';
    const dummyInfo = isDummyActive ? `\n\nDUMMY: groups=(${dummyGroup1.value}, ${dummyGroup2.value})` : '';
    const details = chosen.map(pid => {
      const p = PIECES[pid];
      return `${pid}: type=${p.type} groups=(${p.group1},${p.group2}) bonus=${p.bonus} cost=${p.cost}`;
    }).join('\n');
    showResult(`Team score: ${finalScore.toFixed(3)} (Ruler: ${document.getElementById('ruler').value}, Modifier: ${modifierSelect.value})`,
      `${details}${dummyInfo}\n\nGroup counts: ${JSON.stringify(res.detail.groupCounts, null, 2)}`);
  }));

  // Find random strong (used by Generate)
  function findRandomStrongGroup(minScore=10.0, maxScore=11.11, attempts=200000) {
    const combos = [];
    const keys = allIds;
    const baseRequired = (document.getElementById('ruler').value === 'Elixir Loong') ? 7 : 6;
    const isDummy = modifierSelect.value === 'Trait Dummy';
    const pickCount = isDummy ? baseRequired - 1 : baseRequired;
    for (let i=0;i<attempts;i++) {
      const pool = keys.slice();
      const pick = [];
      for (let j=0;j<pickCount;j++) {
        const idx = Math.floor(Math.random()*pool.length);
        pick.push(pool.splice(idx,1)[0]);
      }
      const sc = scoreGroup(pick).final;
      if (sc >= minScore && sc <= maxScore) combos.push({score: sc, pick});
    }
    if (combos.length === 0) return [null,null];
    return randomChoice(combos);
  }

  // GENERATE button
  document.getElementById('genBtn').addEventListener('click', ()=> safeRun(()=> {
    const res = findRandomStrongGroup(10.0, 11.11, 200000);
    if (!res || !res.pick) { alert('No strong team found'); return; }
    const { pick, score } = res;
    const details = pick.map(pid => `${pid}: ${PIECES[pid].type} (${PIECES[pid].group1},${PIECES[pid].group2})`).join('\n');
    showResult(`Random team â€” Score: ${score.toFixed(3)}`, details);
  }));

  // Custom modal open/close (reuse existing fields)
  document.getElementById('customBtn').addEventListener('click', ()=> modal.style.display='flex');
  document.getElementById('closeModal').addEventListener('click', ()=> modal.style.display='none');

  // FIND CUSTOM
  document.getElementById('findCustom').addEventListener('click', ()=> safeRun(()=> {
    const minScore = parseFloat(document.getElementById('minScore').value) || 10.0;
    const reqTroops = document.getElementById('reqTroops').value.toUpperCase().split(',').map(x=>x.trim()).filter(x=>x);
    const reqGroupsRaw = document.getElementById('reqGroups').value.toUpperCase().split(',').map(x=>x.trim()).filter(x=>x);
    const reqGroups = {};
    for (const g of reqGroupsRaw) {
      const [gname,count] = g.split(':'); reqGroups[gname] = parseInt(count||1);
    }

    const keys = allIds;
    const baseRequired = (document.getElementById('ruler').value === 'Elixir Loong') ? 7 : 6;
    const isDummy = modifierSelect.value === 'Trait Dummy';
    const pickCount = isDummy ? baseRequired - 1 : baseRequired;
    let best = null;
    for (const combo of combinations(keys, pickCount)) {
      if (reqTroops.some(rt => !combo.includes(rt))) continue;
      let ok = true;
      for (const [gname, need] of Object.entries(reqGroups)) {
        let present = 0;
        for (const pid of combo) {
          const piece = PIECES[pid];
          if (!piece) continue;
          if (piece.group1 === gname || piece.group2 === gname) present++;
        }
        if (present < need) { ok = false; break; }
      }
      if (!ok) continue;
      const sc = scoreGroup(combo).final;
      if (sc >= minScore) { best = {combo, sc}; break; }
    }

    if (!best) { showResult('No team found matching conditions', 'Try lowering requirements.'); return; }
    const details = best.combo.map(pid => `${pid}: ${PIECES[pid].type} (${PIECES[pid].group1},${PIECES[pid].group2})`).join('\n');
    showResult(`Custom found â€” Score: ${best.sc.toFixed(3)}`, details);
  }));

  // BEST exhaustive search
  document.getElementById('bestBtn').addEventListener('click', ()=> safeRun(()=> {
    let bestScore = -Infinity, bestTeam = null;
    const keys = allIds;
    const baseRequired = (document.getElementById('ruler').value === 'Elixir Loong') ? 7 : 6;
    const isDummy = modifierSelect.value === 'Trait Dummy';
    const pickCount = isDummy ? baseRequired - 1 : baseRequired;
    let count = 0;
    for (const combo of combinations(keys, pickCount)) {
      count++;
      const sc = scoreGroup(combo).final;
      if (sc > bestScore) { bestScore = sc; bestTeam = combo; }
    }
    const details = bestTeam.map(pid => `${pid}: ${PIECES[pid].type} (${PIECES[pid].group1},${PIECES[pid].group2})`).join('\n');
    showResult(`Best of ${count} combos â€” Score: ${bestScore.toFixed(3)}`, details);
  }));

  // done
  </script>
</body>
</html>
